---
title: "C++ STL 数据结构模板的运用"
published: 2021-08-11T19:27:00
description: '本文根据CCF NOI 竞赛大纲 的顺序编写。 栈（stack） 栈是一种先进后出的数据结构。使用 STL 的 stack 数据结构需要以下头文件： #include &lt;stack&gt; 以下'
tags: [ 数据结构 ]
category: OI
---

本文根据CCF [NOI 竞赛大纲](https://www.noi.cn/upload/resources/file/2021/04/06/152179.pdf) 的顺序编写。

# 栈（stack）

**栈**是一种先进后出的数据结构。使用 STL 的 stack 数据结构需要以下头文件：

```cpp
#include <stack>
```

以下是 stack 常用函数（用例中栈名为 $s$）：

| 函数      | 语法              | 用例             | 作用             | 类型 |
| --------- | ----------------- | ---------------- | ---------------- | :--: |
| `push()`  | `栈名.push(元素)` | `s.push(a)`      | 在栈顶插入新元素 | 操作 |
| `pop()`   | `栈名.pop()`      | `s.pop()`        | 弹出栈顶元素     | 操作 |
| `top()`   | `栈名.top()`      | `a = s.top()`    | 访问栈顶元素     | 查询 |
| `size()`  | `栈名.size()`     | `len = s.size()` | 查询栈中元素数量 | 查询 |
| `empty()` | `栈名.empty()`    | `f = s.empty()`  | 查询栈是否为空   | 查询 |

# 队列（queue）

**队列**是一种先进出的数据结构。使用 STL 的 queue 数据结构需要以下头文件：

```cpp
#include <queue>
```

以下是 queue 常用函数（用例中队列名为 $q$​）：

| 函数      | 语法                | 用例             | 作用                 | 类型 |
| --------- | ------------------- | ---------------- | -------------------- | :--: |
| `push()`  | `队列名.push(元素)` | `q.push(a)`      | 在队列末端插入新元素 | 操作 |
| `pop()`   | `队列名.pop()`      | `q.pop()`        | 弹出队列头端元素     | 操作 |
| `front()` | `队列名.front()`    | `a = q.front()`  | 访问队头元素         | 查询 |
| `back()`  | `队列名.back()`     | `a = q.back()`   | 访问队尾元素         | 查询 |
| `size()`  | `队列名.size()`     | `len = q.size()` | 查询队列中元素数量   | 查询 |
| `empty()` | `队列名.empty()`    | `f = q.empty()`  | 查询队列是否为空     | 查询 |

# 链表（list）

**链表**是一种数据结构。使用 STL 的 list 数据结构需要以下头文件：

```cpp
#include <list>
```

链表的函数有点多啊，不是我说……

以下是 list 常用函数（用例中链表名为 $l$​）（参考了[这篇博客](https://www.cnblogs.com/linuxAndMcu/p/10260627.html)）：

| 函数            | 语法                                                         | 用例                                      | 作用                                                         | 类型 |
| --------------- | ------------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------------------ | :--: |
| `push_front()`  | `链表名.push_front(元素)`                                    | `l.push_front(a)`                         | 在链表头端插入新元素                                         | 操作 |
| `push_back()`   | `链表名.push_back(元素)`                                     | `l.push_back(a)`                          | 在链表尾端插入新元素                                         | 操作 |
| `insert()`（1） | `链表名.insert(要插入元素的位置, 元素)`                      | `l.insert(l.begin(), a)`                  | 在任意位置插入新元素                                         | 操作 |
| `insert()`（2） | `链表名.insert(要插入元素的位置, 要插入的数量, 元素)`        | `l.insert(l.begin(), 3, a)`               | 在任意位置插入多个新元素                                     | 操作 |
| `insert()`（3） | `链表名.insert(要插入元素的位置, 要插入数据的起始位置, 要插入数据的结束位置)` | `l.insert(l.begin(), v.begin(), v.end())` | 插入另一个向量两点之间的数据                                 | 操作 |
| `pop_front()`   | `链表名.pop_front()`                                         | `l.pop_front()`                           | 弹出链表头端元素                                             | 操作 |
| `pop_back()`    | `链表名.pop_back()`                                          | `l.pop_back()`                            | 弹出链表尾端元素                                             | 操作 |
| `erase()`（1）  | `链表名.erase(要删除元素的位置)`                             | `l.erase(l.end())`                        | 删除任意位置的元素                                           | 操作 |
| `erase()`（2）  | `链表名.erase(要删除元素的起始位置, 要删除元素的结束位置)`   | `l.erase(l.begin(), l.end())`             | 删除连续多个任意位置的元素                                   | 操作 |
| `clear()`       | `链表名.clear()`                                             | `l.clear()`                               | 清空所有元素                                                 | 操作 |
| `assign()`      | `链表名.assign(赋值的数量, 要赋的值)`                        | `l.assign(4, 5)`                          | 为链表赋多个初值                                             | 操作 |
| `swap()`（1）   | `链表名1.swap(链表名2)`                                      | `l1.swap(l2)`                             | 交换两个链表的值                                             | 操作 |
| `swap()`（2）   | `swap(链表名1, 链表名2)`                                     | `swap(l1, l2)`                            | 交换两个链表的值                                             | 操作 |
| `merge()`       | `链表名1.merge(链表名2)`                                     | `l1.merge(l2)`                            | 将一个链表合并入另一个链表，并按照链表的升序排列**（注意不是链表中元素的升序）**；并将这个链表清空 | 操作 |
| `splice()`      | `链表名1.splice(插入的位置，链表名2)`                        | `l1.splice(l1.begin(), l2)`               | 在一个链表的任意位置插入另一个链表；并将这个链表清空         | 操作 |
| `unique()`      | `链表名.unique()`                                            | `l.unique()`                              | 删除链表中相邻的重复元素                                     | 操作 |
| `begin()`       | `链表名.begin()`                                             | `l.begin()`                               | 链表开始迭代器指针                                           | 查询 |
| `end()`         | `链表名.end()`                                               | `l.end()`                                 | 链表末尾迭代器指针                                           | 查询 |
| `cbegin()`      | `链表名.cbegin()`                                            | `l.cbegin()`                              | 指向常量的开始迭代器指针                                     | 查询 |
| `cend()`        | `链表名.cend()`                                              | `l.cend()`                                | 指向常量的末尾迭代器指针                                     | 查询 |
| `rbegin()`      | `链表名.rbegin()`                                            | `l.rbegin()`                              | 反向迭代器指针，指向最后一个元素                             | 查询 |
| `rend()`        | `链表名.rend()`                                              | `l.rend()`                                | 反向迭代器指针，指向第一个元素的前一个元素                   | 查询 |
| `front()`       | `链表名.front()`                                             | `a = l.front()`                           | 访问链表头元素                                               | 查询 |
| `back()`        | `链表名.back()`                                              | `a = l.back()`                            | 访问链表尾元素                                               | 查询 |
| `size()`        | `链表名.size()`                                              | `len = l.size()`                          | 查询链表中元素数量                                           | 查询 |
| `empty()`       | `链表名.empty()`                                             | `f = l.empty()`                           | 查询链表是否为空                                             | 查询 |

以下是 list 常用函数（用例中链表名为 $l$​）：

- 遍历元素

```c++
list<int>::iterator it;
for (it = lst.begin(); it != lst.end(); it++)
    cout << *it << endl;
```

- 元素翻转

```cpp
#include <algorithm>
reverse(lst.begin(), lst.end());
```

- 元素排序

```cpp
#include <algorithm>
sort(lst.begin(), lst.end()); // 采用的是从小到大的排序

// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:
// 自定义从大到小的比较器，用来改变排序方式
bool Comp(const int& a, const int& b) 
{
    return a > b;
}

sort(lst.begin(), lst.end(), Comp);
```



# 向量（vector）

**向量**是一种数据结构。使用 STL 的 vector 数据结构需要以下头文件：

```cpp
#include <vector>
```

以下是 vector 常用函数（用例中向量名为 $l$）：



未完待更……

完了。退役了，更不完了，有人接上这个坑就接上吧，我这给个源码链接，如果有人接上这坑的话回复个链接，我给挂上，就算填了坑了。

[源码链接](https://paste.ubuntu.com/p/G2HwFwC8yd/)